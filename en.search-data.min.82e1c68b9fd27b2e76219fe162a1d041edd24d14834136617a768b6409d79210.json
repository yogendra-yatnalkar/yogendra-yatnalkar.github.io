[{"id":0,"href":"/blogs/backtracking_aws_lookout_for_vision_service.html","title":"Backtracking AWS Lookout for Vision Service","section":"Blogs","content":"\rBacktracking AWS Lookout For Vision Service\r#\rThe article tries to trace back AWS Lookout for Vision: Edge service model and successfully custom loads the model for inference (Just imagine the reduced inference cost ğŸ”¥)\nCo-Author:Â Palash Nimodia\rDate: June 23, 2022\nMedium Link: https://medium.com/@yogenyat/backtracking-aws-lookout-for-vision-service-136c47c85168\rIntroduction:\r#\rNOTE for the reader: Its fine if you have not used AWS Lookout For Vision service before, but if you are interested in knowing how we can back-track a managed service (if possible ğŸ™ˆ), you are at the right place.\nAmazon Lookout for Vision (LFV)Â has recently released preview support for anomaly detection at the edge. It is a machine learning (ML) service that spots defects and anomalies in visual representations of manufactured products using computer vision (CV), allowing users to automate quality inspection. ML model is trained to spot anomalies from live production lineÂ with as few as 30 images for the process which needs to be visually inspectedÂ â€” with no machine learning experience required.Â Now, in addition to detecting anomalies in the cloud, Amazon LFV model can be hosted on edge using AWs IoT Greengrass V2 compatible edge devices.\nPrerequisite:\nâ†’ Train a Lookout For Vision Model using AWS Console\nâ†’ Compile and package the model for edge hosting\nâ†’Â The below work has been tested on EC2 instance and SageMaker Notebook Instance (EC2 instance as edge) having Nvidia T4 GPU (instance â€” G4dn.xlarge)\nOnce training and packaging the trained model is complete, our journey starts here.\nWe try to trace-back the service to identify how the LFV service trains its anomaly detection model, what post-processing it performs on the trained model and if there is any minute chance of custom hosting it for inference.\nTHE JOURNEY BEGINS:\r#\rA. Model Packaging:\r#\rA model packaging job packages an Amazon Lookout for Vision model as a model component. While packaging your custom trained model, there is an option forÂ target-deviceÂ andÂ target-platform. Since we are testing this on EC2 instance, we will choose our target as:Â target-platformÂ in this case.\nAfter choosing the platform, we will chooseÂ compiler-options.Â Within compiler option, we will have to provide the GPU which we will be using, the tensorrt version and the Cuda library version. For more details, please follow the documentation at the following link:Â LINK\rOur configuration for G4dn.xlarge Instance:\n{â€˜gpu-codeâ€™: â€˜sm_75â€™, â€˜trt-verâ€™: â€˜7.1.3â€™, â€˜cuda-verâ€™: â€˜10.2â€™}\nSo here comes our first clue, the service is post-processing our model by optimizing it usingÂ NVIDIA TensorRT SDK.\nQuestion:Â We still do not know if the following model is trained usingÂ Tensorflow or Pytorch or any other Deep Learning frameworkâ€¦ !!\nB. Analyzing Zipped model\r#\rImage Description: Zipped Model Contents\nZipped Model contents\nOnce the model is trained â†’ compiled â†’ TensorRT optimized, it gets saved to AWS S3 in a zipped format. In our case, the zip file and contents within the zip looked something like image above:\nIf we closely observe, there are two things inside it:\nFolder â€” â€œmochiâ€ (including the sub-files within this folder) manifest.json file TheÂ manifest.json fileÂ contains the following contents:\n{\u0026ldquo;model_graph\u0026rdquo;: {\u0026ldquo;model_graph_type\u0026rdquo;: \u0026ldquo;single_stage_model_graph\u0026rdquo;, \u0026ldquo;stages\u0026rdquo;: [{\u0026ldquo;class_normal_ids\u0026rdquo;: [1], \u0026ldquo;seg_normal_ids\u0026rdquo;: [], \u0026ldquo;classification_head_enabled\u0026rdquo;: true, \u0026ldquo;segmentation_head_enabled\u0026rdquo;: false, \u0026ldquo;threshold\u0026rdquo;: 0.7021560668945312, \u0026ldquo;normalize\u0026rdquo;: true, \u0026ldquo;image_range_scale\u0026rdquo;: true, \u0026ldquo;image_width\u0026rdquo;: 1000, \u0026ldquo;image_height\u0026rdquo;: 1000, \u0026ldquo;input_shape\u0026rdquo;: [1, 3, 1000, 1000], \u0026ldquo;type\u0026rdquo;: \u0026ldquo;mochi\u0026rdquo;}], \u0026ldquo;image_level_classes\u0026rdquo;: {\u0026ldquo;names\u0026rdquo;: [\u0026ldquo;anomaly\u0026rdquo;, \u0026ldquo;normal\u0026rdquo;], \u0026ldquo;normal_ids\u0026rdquo;: [1]}, \u0026ldquo;pixel_level_classes\u0026rdquo;: {\u0026ldquo;names\u0026rdquo;: [], \u0026ldquo;normal_ids\u0026rdquo;: []}}, \u0026ldquo;compilable_models\u0026rdquo;: [{\u0026ldquo;filename\u0026rdquo;: \u0026ldquo;mochi.pt\u0026rdquo;, \u0026ldquo;data_input_config\u0026rdquo;: {\u0026ldquo;input\u0026rdquo;: [1, 3, 1000, 1000]}, \u0026ldquo;framework\u0026rdquo;: \u0026ldquo;PYTORCH\u0026rdquo;}], \u0026ldquo;dataset\u0026rdquo;: {\u0026ldquo;image_width\u0026rdquo;: 1000, \u0026ldquo;image_height\u0026rdquo;: 1000}}\nThe Analysis from the folder and JSON file is as follows:\r#\rThe folder name itself is quite unique and hence raises a question: CouldÂ â€œmochiâ€Â be some latest/open-source model ? The JSON file contains a key-word named:Â â€œmochi.ptâ€ Web-searching on the â€œmochiâ€ term led to an interesting discovery. It resulted in the following paper:Â Hard Negative Mixing for Contrastive LearningÂ (Paper Link)\rwhereÂ MoCHIÂ stands forÂ â€œ(M)ixing (o)fÂ (C)ontrastive (H)ard negat(i)vesâ€. The paper proposes aÂ semi-supervised wayÂ of training Deep Learning models usingÂ Contrastive Loss where it highlights the importance of â€œHard-negativesâ€.Â The proposed approach generates synthetic hard negatives on-the-fly for each positive (query). (Note:Â Please read about contrastive loss and semi-supervised learning for more details â€¦â€¦ this was first time for me as-wellğŸ˜¢) Illustration ofÂ MoCHi\nIt could be assumed that Lookout for Vision has aÂ pre-trained semi-supervised defect detection model. For new model training on customer data, this pre-trained model is further fine-tuned on new data and saved. Hence, this can be also related to theÂ unique featureÂ of the service, which is theÂ need for a very small amount of annotated dataÂ as it could be using semi-supervised learning algorithm internally.\nContent within manifest.json fileâ€¦\nNow, lets have a quick peek atÂ content.jsonÂ file:\nIt tells us that the trained model is aÂ â€œPytorchâ€ modelÂ with model name as:Â mochi.pt. The model is trained and inferred on shape:Â 1000x1000x3 Even though the service only supports binary classification, the model has 2 output neurons. One output states whether the input image is â€œnormalâ€ or not. Another output states whether the input image is â€œanomalyâ€ or not. The threshold for detecting output is set at:Â **0.7021 (at-least to the model trained in our case)\n**- There is key-value pair named: â†’Â â€œnormalizedâ€: True.Â From here, we can assume that the output of the last layer isÂ Normalized using Softmax layer. Now, lets quickly analyze the other sub-files from the â€œmochiâ€ folder.\nTheÂ libdlr.so file and dlr.h fileÂ tells us that the model is compiled usingÂ Neo-AI-DLR package (LINK).\r-Â DLR is a compact, common runtime for deep learning models and decision tree models compiled byÂ AWS SageMaker Neo\r,Â TVM\r, orÂ Treelite\r. DLR uses the TVM runtime, Treelite runtime, NVIDIA TensorRTâ„¢, and can include other hardware-specific runtimes. TheÂ libdlr.so fileÂ in the model zip specifies the platform details of the compiled model while custom loading inÂ NeoAI-dlr.Â Hence, itâ€™s required while loading the model on any g4dn.xlarge instance (Nvidia T4 GPU) (Note: Our model was compiled for Nvidia T4 GPU)\nC. Edge Model Custom Loading:\r#\rWe have learnt a lot about this model now. Somehow, lets crack the hidden mystery on how to load it manually without using AWS SDKâ€¦.\nRequirements:\r#\rInstance with Nvidia T4 GPU (Tested on SageMaker Notebook and EC2 instance of type: g4dn.xlarge) DLR\rinstalled with GPU support. It can be installed by building from source or usingÂ **pip with pre-built binaries. (**on development instance, it was installed using:Â pip install {prebuilt supported binary} ) Edge model zip file locally available and unzipped. Python libraries required:Â dlr, numpy, cv2, os, torch Image pre-processing before inference:\r#\r(IMPORTANT NOTE:Â The below listed pre-processing was found using multiple trial and error by comparing custom loaded model inference with the console displayed information)\nRead the image using Opencv (cv2) image library ConvertÂ BGRÂ channel image toÂ RGBÂ channel image (Opencv image are read in BGR channel) Resize the image to size:Â 1000x1000 (3 channel) Normalize the image between scale:Â 0â€“1 (divide by 255) Standardize the image withÂ **ImageNet channel wise mean and standard deviation (order: RGB): mean=[0.485, 0.456, 0.406] standard-deviation (std) =[0.229, 0.224, 0.225]** Make the image channel firstÂ (Earlier: 1000x100x3, After: 3x1000x1000) Expand image dimension to treat it as batch size 1 for inference.Â (final dimension: 1x3x1000x1000) Model Loading and Inference:\r#\rWe have finally analyzed multiple things and came to few major conclusions, such as:\nThe training is performed using Pytorch Library The model is TensorRT optimized The model is compiled using NeoAI-DLR package for Nvidia GPU The trained model is a Semi-supervised model (MOCHI) Inference Image Size: 1000x1000x3 Image Pre-processing decoded(mean, standard-deviation, order of image channel) Code to load the model using DLR package and inference. lookout_for_vision_custom_loading.py Â· GitHub\rimport dlr import numpy as np import cv2 import os # DLR installation # pip install https://neo-ai-dlr-release.s3-us-west-2.amazonaws.com/v1.10.0/gpu/dlr-1.10.0-py3-none-any.whl # Load model. # /path/to/model is a directory containing the compiled model artifacts (.so, .params, .json) model = dlr.DLRModel(\u0026#39;./mochi/\u0026#39;, \u0026#39;gpu\u0026#39;, 0) def process_image(img): # normalizing the image (0-1) and # standardizing with ImageNet Mean and Std-deviation img = img/255 img[:,:,0] = (img[:,:,0] - 0.485)/0.229 img[:,:,1] = (img[:,:,1] - 0.456)/0.224 img[:,:,2] = (img[:,:,2] - 0.406)/0.225 # convert image to channel first from channel last img = img.transpose(2,0,1) # Expanding dimension to treat it as batch-size: 1 img = np.expand_dims(img, axis = 0) return img def predict_on_image(img_path, model): # read image and convert to RGB img = cv2.imread(img_path) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # resize the images if needed # Process image img = process_image(img) # infer and print result y = model.run(img) return round(y[0][0][0], 3), round(y[0][0][1], 3), np.argmax(y) folder_path = \u0026#39;./temp/\u0026#39; for img_name in sorted(os.listdir(folder_path)): if(\u0026#39;.jpg\u0026#39; not in img_name): continue img_path = os.path.join(folder_path, img_name) print(img_name) a,b,c = predict_on_image(img_path, model) print(c,\u0026#39;====\u0026#39;, a,b) We were able to successfully load and infer on our test images using the above attached code.Â To validate our work, we performed one experiment on it which is as follows:\nâ€” Took one image data-set and converted it to train and test set\nâ€” Train the model on train-set using AWS console and package it for edge such that its zip file is saved in S3. Fetch the zip file and store it in test-environment\nâ€” Infer the model on the cloud using the AWS Console on the test-set. Record its results and model confidence\nâ€” Now, infer using the edge-model on the testing instance using the above code on the test-set images. Record the results and confidence score\nResult:\r#\rWe observed that, when the test-set was inferred on the edge using custom loading of the model, the inference results and the confidence scores were exactly identical as compared with the AWS LFV Console inference.\nWith this in hand, we can easily see how much cost we could save in future, as we will only have to bear the training cost and avoid all the AWS API/SDK inference cost. Lets say, we are on a NVIDIA Jetson device and we have trained a AWS LFV model, we will be able to directly infer on new images/video-frames using custom loading.\nIf you have actually read this much and liked it, please do not forget to give aÂ clap and subscribe for future articlesâ€¦..\nTHE ENDâ€¦..\nTags AWS, Computer Vision, Pytorch, Deep Learning, Cloud Computing "},{"id":1,"href":"/blogs/finding-nth-aggregate-from-every-group-aws-athena.html","title":"Finding the nâ€™th Aggregate Value from Every Group in AWS Athena/Presto","section":"Blogs","content":"\rFinding the nâ€™th Aggregate Value from Every Group in AWS Athena/Presto\r#\rCo-Author:Â Palash Nimodia\rDate: June 2, 2022\nMedium Link: https://medium.com/selectfrom/finding-the-nth-aggregate-value-from-every-group-in-aws-athena-presto-1da505310901\rPrerequisite:\r#\rBefore going ahead, a quick read for those who donâ€™t know what AWS Athena and Presto are.\nAWS Athena: Amazon Athena is an interactive query service that makes it easy to analyze data in Amazon S3 using standard SQL. Athena is easy to use, fast, scalable and serverless, so there is no infrastructure to manage, and we pay only for the queries that we run. We also donâ€™t have to pay for failed queries. This makes it easy for anyone with SQL skills to quickly analyze large-scale datasets.\nPresto: Presto is an open source distributed SQL query engine for running interactive analytic queries against data sources of all sizes ranging from gigabytes to petabytes. AWS Athena uses Presto internally as its query engine.\nIntroduction:\r#\rContinuing on with our main focus, today we will discuss finding the nth aggregate value from every group in AWS Athena/Presto).\nLetâ€™s take an example: finding some aggregate value from every group in SQL is possible and its solutions are quite easily available. Across the few solutions that I went through, two things were common:\nIt always referred to the 2nd highest/lowest. Most of the solutions used SQL variables and inner join. Now imagine a scenario where you are required toÂ find the 5thâ€¦. 6thâ€¦. nth largest/smallest/aggregate value from every group where data size is HUGE (in TBâ€™s) and you are restricted from using SQL variables.\nIn such scenarios, due to the sheer scale, inner-join will be a very heavy operation and hence its best to avoid it. Another restriction being the use of variables in AWS Athena. Since AWS Athena is used for data analytics and not transactional databases, the use of variables is not supported as of now.\nSo after the above discussion, is there any other way ???Â â€¦â€¦ Yes, there is.Â Letâ€™s have a quick look at the dummy data-set first and then move onto our solution.\nThe dummy data-set has 1,000 rows and 4 columns. TheÂ â€œidâ€Â column has 10 unique values of typeÂ varchar. TheÂ â€œdateâ€Â column is of typeÂ date-type. TheÂ â€œclass-typeâ€Â column is of data-typeÂ varcharÂ containing values namely:Â â€œextraâ€, â€œvipâ€, â€œnormalâ€. TheÂ â€œclass-marksâ€Â column containsÂ integersÂ ranging between 0 and 100.\nThis is how the dummy data-set looks\nData Download:Â The dummy data-set is very small in size and it is uploaded on GitHub â€”Â augmented-data.csv\rLetâ€™s define a question now:\nQuestion 1:\r#\rFor every ID, find the 5th highest scorer from every unique â€œclass-typeâ€.\nPre-work:Â The above data-set is uploaded onÂ AWS S3Â and crawled usingÂ AWS Glue. This crawled table is now easily accessible usingÂ AWS Athena.\nSolution:\r#\rLetâ€™s divide the solution into 3 parts, hence containing 3 nested queries.Â (The entire query is attached at part 3)\nPart 1:\r#\râ€” â€” â€” â€” â€” â€”\nAs we are required to compute the highest scorer, we will need to sort the table based on marks in descending order. The query to perform that will be as follows:\nâ€” â€” â€” â€” â€” â€”\nQuery1:\r#\rWITH \u0026#34;sorted_marks_table\u0026#34; AS( SELECT * FROM \u0026#34;augmented_data\u0026#34; ORDER BY \u0026#34;augmented_data\u0026#34;.\u0026#34;class-marks\u0026#34; DESC ) SELECT * FROM \u0026#34;sorted_marks_table\u0026#34;; Query1 Output:\r#\raugmented_dataÂ table in sorted order\nPart2:\r#\râ€” â€” â€” â€” â€” â€”\nIn the next part, letâ€™s work on grouping. We need to compute the highest scorer for every ID, hence we will need toÂ group by on the ID column. In this sub-query, we will create a mapping (you can imagine a hash-map/dictionary) between â€œclass-typeâ€ and â€œclass-marksâ€ columnÂ andÂ group by on â€œidâ€ column.Â It will be such that for every unique id the map key will be unique class type and value will be a list consisting of all the marks associated with that id and class name.\nPlease observe the output image, since we had already sorted the table based on marks in the earlier sub-query, the value list is also sorted in the highest to lowest marks(descending).\nâ€” â€” â€” â€” â€” â€”\nQuery2 (In combination with Query1):\r#\rWITH \u0026#34;sorted_marks_table\u0026#34; AS( SELECT * FROM \u0026#34;augmented_data\u0026#34; ORDER BY \u0026#34;augmented_data\u0026#34;.\u0026#34;class-marks\u0026#34; DESC ), \u0026#34;mapping_table\u0026#34; AS ( SELECT id, multimap_agg(\u0026#34;class-type\u0026#34;, \u0026#34;class-marks\u0026#34;) AS \u0026#34;mapping_col\u0026#34; FROM \u0026#34;sorted_marks_table\u0026#34; GROUP BY \u0026#34;id\u0026#34; ) SELECT * FROM \u0026#34;mapping_table\u0026#34;; Query2 Output:\r#\rTable grouped on â€œidâ€ column such that all the marks are associated with the unique class-types.\nPart3 (Final):\r#\râ€” â€” â€” â€” â€” â€”\nNow, in the final part we just need to display the required results from our map. As we have all the marks in sorted order for every class type and we need the 5th highest scorer, we willÂ select the 5th place value from every key of the map.\nOne caveat of this solution is that we need to know the unique keys beforehand and need to explicitly specify the key-name. But there is a reason behind this, unlike some programming languages like Python or Java, we are using a form of SQL and we need to know the schema of the Database before-hand.\nâ€” â€” â€” â€” â€” â€”\nQuery3:\r#\rWITH \u0026#34;sorted_marks_table\u0026#34; AS( SELECT * FROM \u0026#34;augmented_data\u0026#34; ORDER BY \u0026#34;augmented_data\u0026#34;.\u0026#34;class-marks\u0026#34; DESC ), \u0026#34;mapping_table\u0026#34; AS ( SELECT id, multimap_agg(\u0026#34;class-type\u0026#34;, \u0026#34;class-marks\u0026#34;) AS \u0026#34;mapping_col\u0026#34; FROM \u0026#34;sorted_marks_table\u0026#34; GROUP BY \u0026#34;id\u0026#34; ) SELECT \u0026#34;id\u0026#34;, mapping_col [ \u0026#39;normal\u0026#39; ] [ 5 ] as \u0026#34;normal_max_5th\u0026#34;, mapping_col [ \u0026#39;vip\u0026#39; ] [ 5 ] as \u0026#34;vip_max_5th\u0026#34;, mapping_col [ \u0026#39;extra\u0026#39; ] [ 5 ] as \u0026#34;extra_max_5th\u0026#34; FROM \u0026#34;mapping_table\u0026#34;; Query3 Output:\r#\rFinal output containing the 5th highest marks from everyâ€˜ class-typeâ€™ for every â€˜idâ€™\nThatâ€™s it! We are done and dusted. We have found the 5th largest scorer for every id for every â€œclass-typeâ€.\nâ€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€” â€”\nAre we not done? Why is this blog not ending here?\nLetâ€™s try computing another very similar question.\nQuestion2:\r#\rFor every ID, find the 3rd lowest scorer from every unique â€œclass-typeâ€\r#\rSolution:\r#\rWITH \u0026#34;sorted_marks_table\u0026#34; AS( SELECT * FROM \u0026#34;augmented_data\u0026#34; ORDER BY \u0026#34;augmented_data\u0026#34;.\u0026#34;class-marks\u0026#34; ), \u0026#34;mapping_table\u0026#34; AS ( SELECT id, multimap_agg(\u0026#34;class-type\u0026#34;, \u0026#34;class-marks\u0026#34;) AS \u0026#34;mapping_col\u0026#34; FROM \u0026#34;sorted_marks_table\u0026#34; GROUP BY \u0026#34;id\u0026#34; ) SELECT \u0026#34;id\u0026#34;, mapping_col [ \u0026#39;normal\u0026#39; ] [ 3 ] as \u0026#34;normal_max_3rd\u0026#34;, mapping_col [ \u0026#39;vip\u0026#39; ] [ 3 ] as \u0026#34;vip_max_3rd\u0026#34;, mapping_col [ \u0026#39;extra\u0026#39; ] [ 3 ] as \u0026#34;extra_max_3rd\u0026#34; FROM \u0026#34;mapping_table\u0026#34;; Question2 Output:\r#\rFinal output containing the 3rd lowest marks from everyâ€˜ class-typeâ€™ for every â€˜idâ€™\nSo what did we change:\nWe sorted the table in ascending order in the first part of the query and selected the 3rd element this time.\nThatâ€™s it! GG! ğŸ‘\nI hope you found this article instructional and informative. If you have any feedback or queries, please let me know in the comments below.\nTags AWS, SQL, Presto, Data Science, Data "},{"id":2,"href":"/notes/nlp/bert.html","title":"BERT","section":"NLP","content":" BERT (Bidirectional Encoder Representation From Transformer)\r#\rSource:\nBERT: Pre-training of Deep Bidirectional Transformers for Language Understanding - YouTube\rOriginal Paper: https://arxiv.org/pdf/1810.04805v2.pdf\rSource:\nBERT Neural Network - EXPLAINED! - YouTube\rBefore BERT:\r#\rLSTM\u0026rsquo;s were used.\nProblems:\nSlow as each word is processed at a time (sequentially) Not truly bi-directional (left to right and right to left at a time in bidirectional LSTM) Bert Architecture: Multiple encoders stacked on each-other\nPretraining and Finetuning\nPretraining Task is used to learn the language and its context. It is done using two tasks:\nMask Language Model (MLM):\nSentence sentence {Fill_in_the_Blanks} remaining sentence\nHelps bert understand the bidirectional meaning of a sentence\nNext Sentence Prediction (NSP):\nPredict whether the a given sentence is the next sentence of the current sentence. Like a binary classification task.\nIt helps bert in understanding context across different sentences.\nUsually, the MLM task and NSP task are performed simultaneously.\nFinetuning:\nFinetune on task specific data.\nFast and compute efficient\nOnly replace last few layers of the original architecture\n"},{"id":3,"href":"/notes/general/general-general.html","title":"General Notes","section":"General","content":"\rLinux:\r#\rWget vs Curl\r#\rcurl and wget both support http and various types of FTP protocols. curl is library but wget is a CLI tool. curl is used for both way data transfer (src to detination and vice-versa) But, wget can be used only for single way data transfer, example: downloading something form a web-server. "},{"id":4,"href":"/notes/general/kl-divergence.html","title":"Kullback-Leibler Divergence (KL Divergence)","section":"General","content":"\rKullback-Leibler Divergence (KL Divergence)\r#\rLast Edited 25/06/2023 Definition:\r#\rMeasures the distance between 2 prabability distributions Explanation + Proof:\r#\rBase Video: Intuitively Understanding the KL Divergence - YouTube\rSequence of flips: H -\u0026gt; H -\u0026gt; T \u0026hellip;..\nMultiply the probabilities from both the coins for the corresponding heads and tails. It is nothing but:\nfor True coin: P1 raise to something and P2 raise to something else\nFor coin2: Q1 raise to soemthing and Q2 raise to something else\nafter applying log to the RHS: (** \u0026ndash;\u0026gt; Explained at the end)\nAs the number of observations tends towards infinity:\nNh/n ~~ p1\nNt/N ~~ p2\nThis leads us to the final log expression:\nGeneral Formulae:\r#\r\u0026ldquo;This computes the distance between 2 distributions motivated by looking at how likely the 2nd distribution would be able to generate samples from the first distribution\u0026rdquo;\nCross-entropy Loss is very related to KL Divergence\nImportant Notes:\r#\rKL Divergence is un-symmetric i.e the divergence depends on the distribution placed on the denominator.\nIn other words: Divergence of distribution1 wrt distribution2 is not same as divergence of distribution2 wrt distribution1.\n** Why take log of probability ?\r#\rFrom the probabilities of ratio, why did we suddenly take log of ratio ??\nThe log of probabilities is closely related entropy. InÂ information theory\r, theÂ entropyÂ of aÂ random variable\ris the average level of \u0026ldquo;information\u0026rdquo;, \u0026ldquo;surprise\u0026rdquo;, or \u0026ldquo;uncertainty\u0026rdquo; inherent to the variable\u0026rsquo;s possible outcomes.\nKL Divergence is also known as relative entropy between 2 distributions.\r#\rFor good reference to entropy, watch statquest video:\nEntropy (for data science) Clearly Explained!!! - YouTube\r"},{"id":5,"href":"/notes/nlp/nlp_general.html","title":"NLP-General","section":"NLP","content":"\rNLP General:\r#\rI will keep on appending stuff which I read about NLP as and when I get time in this place This is mainly intended for two things: Quick glance on what I had read in past for a given topic If needed to deep-dive, just look at the sources I used while reading it for the first time Hackers Guide to Language Model:\r#\rSource: A Hackers' Guide to Language Models - YouTube\rNotebook: GitHub - fastai/lm-hackers: Hackers' Guide to Language Models\rDate: 02/11/2023\nOn a high note, what is a language mode:\nPredicts the next word\nor predicts the missing word\nByte-Pair-Encoding tokenizer for OpenAI models: GitHub - openai/tiktoken: tiktoken is a fast BPE tokeniser for use with OpenAI's models.\r\u0026ldquo;NN has got the ability to create rich hierarchy of abstractions and representations on the base training data which is clearly a form of knowledge compression.\u0026rdquo;\nLM\u0026rsquo;s (mainly LLM\u0026rsquo;s) are trained in 3 parts:\nPretrained: Unsupervised training on large corpus of data and building a generalized model. The tasks can be:\nNext word prediction\nMask word and predict the masked word\nLLM Fine-Tuning: Again unsupervised training like next word prediction, but on small amount of task-specific data\nWithin this second step, the paradigm has recently shifted to Instruction Finetuning. In this, the input text is of the form: Instruction \u0026ndash;\u0026gt; Context \u0026ndash;\u0026gt; Question. For further knowledge, a good source is: Instruction Fine-tuning of Large Language Models | Niklas Heidloff\rLlama2-chat models are instruction fine-tuned where the instruction of llama2-chat is quite long for example:\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you donâ€™t know the answer to a question, please donâ€™t share false information.\r\u0026lt;\u0026lt;CONTEXT\u0026gt;\u0026gt;\rQuestion: \u0026lt;\u0026lt;Question\u0026gt;\u0026gt; Classifier fine-tuning:\nReinforcement Learning with Human Feedback:\nGood source to learn is from Yannick\u0026rsquo;s video: Learning to summarize from human feedback (Paper Explained) - YouTube\r(This is the original paper released in 2020 by OpenAI)\nFrom my current understanding, there will be a separate scoring model\nThe LLM would generate some output for the input and scoring model will generate the score for the output.\nThe scoring model will be trained on small supervised data where the scores are generated by humans.\nAs of September 2023, GPT4 is the best SOTA LLM. Listing down few things which GPT4 cannot do:\nHallucinations\nIt doesn\u0026rsquo;t know about itself. (Why not?) \u0026ndash;\u0026gt; Because it was not included in its training and due to RLHF, it is just hallucinating\nIt doesn\u0026rsquo;t know about URLs.\nKnowledge cutoff\nOpenAI Cost:\nSmall Note on GPU Performance per price:\nHigher priced GPU is not always as good as its price because we need GPU having ultra-fast memory transfer speed as compared to ultra-fast compute operations. How to make inference faster in Casual Language Model:\r#\rTo increase performance of LLM prediction, we should try to reduce output tokens as compared to input tokens. It will have HUGE Impact.\nKV Cache\n"},{"id":6,"href":"/notes/cv/sam-segment-anything.html","title":"SAM-Segment-Anything","section":"CV","content":"\rSegment Anything (SAM)\r#\rLast Edited 16/07/2023 Source: - Original Paper (notes till page no 7) - Youtube:Â https://www.youtube.com/watch?v=eYhvJR4zFUM Introduction:\r#\rFoundation model for segmentation.\nImportant thing to note here, is that SAM is not just for semantic segmentation but can also be used for instance or panoptic or salient segmentation as well. We just need to engineer it accordingly.\nTrained ON: 11 million images and 1 billion corresponding masks\nEarlier foundation model: Clip and Align \u0026raquo; Now getting used in other downstream tasks like image generation (DALL-E).\nTo build foundation mode, 3 things are necessary:\nTask\nModel\nDataset and Data-Engine\nTask\r#\rTask: Prompt-able segmentation task \u0026raquo; prompt can be text or mask or BB or points \u0026raquo; even if prompt is not accurate or it is confusing, the output should be good.\nZero-shot transfer: Example- if you have a OD model to detect cats, SAM can be used to segment each cat (instance segmentation) in your image. If you want semantic segmentation, convert that cat instances to single class.\nSAM vs Other multi-segmentation models:\nOther models are not general. They do a set of predefined tasks they are trained on, they can be many but fixed.\nIn case of SAM, it can be engineered to perform any task with itself alone or with other systems (example: OD model or older segmentation model). The prompt makes it key here and forms a general foundation model.\nModel:\r#\rModel: Heavy and powerful image encoder, light prompt encoder, light++ prompt and image decoder.\nImport thing to note: for faster inference, the encoder can be hosted online on server, but prompt encoder and decoder can be hosted on edge (eg. browser). Hence reducing the network latency. ++ We need to encode only once, then we can prompt it as many times as needed.\nSAM predicts multiple masks for single image (to battle confusion)\nImage Encoder: Image encoder is pretrained ViT from MAE (Masked Auto-Encoders are Scalable Vision Learners). In MAE, random patches from ViT are masked and an autoencoder is trained to predict the masked patch.\nSAM uses this MAE encoder as its base encoder\nPrompt Encoder:\nText: Encoded using CLIP\nBounding box coordinates or point coordinates: Positional Encoder with summed learned embedding\nMask: Embedding from CNN\nMask Decoder:\nInspired from original Transformer decoder. (modified)\nOutput of decoder goes to dynamic prediction head\nUses self-attention and cross-attention between prompt and image-embedding in bi-directional way (i.e prompt-to-image embedding and vice-versa)\nLater, up-sample and pass it to a linear classifier\nAmbiguity and Backprop: For each input, 3 masks are predicted and during backprop for loss computation, the mask with least amount of loss is counted. Loss is computed using IoU.\nEfficiency: Post encoder embedding, the prompt encoder and decoder can work on CPU (web-browser) with 50 ms latency.\nLoss metrics used: Focal loss and Dice Loss\nFocal Loss: Focal Loss is am improved version of Cross-Entropy Loss that tries to handle the class imbalance problem by down-weighting easy negative class and focusing training on hard positive classes. In paper, Focal Loss is mathematically defined as: Reference: Understanding Cross-Entropy Loss and Focal Loss | Multiplying Matrices for a living (theguywithblacktie.github.io)\r(Do read it, very good explanation) Note: Focal loss was initially used for object detection (invented at FAIR)\nDice Loss: Dice loss is 1 - Dice Coefficient. You can directly imagine Dice Coefficient as IoU.\nDataset\r#\rDataset and Data-Engine: 11 mil images, 1 billion masks. Tag with the help of model, retrain and retag \u0026ndash;\u0026gt; Cycle continues\u0026hellip;\nResponsible AI: Images are taken from all over the globe across all human species. "},{"id":7,"href":"/notes/cv/segformer.html","title":"SegFormer: Segmentation using Transformer","section":"CV","content":"\rSegFormer: Segmentation using Transformer\r#\rLast Edited 16/07/2023 Source: SegFormer: Simple and Efficient Design for Semantic Segmentation with Transformers - YouTube\rInput patch size: 4x4\nIn ViT, it was 16x16, but with smaller path size, the authors said, smaller batch size is better (and required) for dense prediction.\nNote: With reducing the patch size, the computation increases.\nAfter each transformer block (encoder in this case), there is a feed-forward block which is mainly used to lower the dimension like older UNet \u0026ndash;\u0026gt; i.e in HxWxC \u0026hellip;. as we go ahead in the encoder block, the height and width will decrease but the number of channels will keep on increasing.\nIn normal ViT as well, there are multiple transformer blocks, output dimension of each block of encoder is same its input.\nThese MLP blocks used in the encoder (Not transformer encoder), not just downsample the input (and increase channels) but also dynamically adjusts the patch embedding vector passed on to the next transformer block.\nEfficient self-attention reduces the sequence to lower computation cost (NOTE: Later need to read about efficient self attention)\nThe segformer decoder consists of Dense NN (MLP) which has upsamping blocks in between.\nImportant: One big achievement of segformer is, it not just has high mIoU, its Params size is also very small\u0026hellip;.. hence inference speed is also high.\n"},{"id":8,"href":"/notes/cv/self-supervised-learning.html","title":"Self Supervised Learning","section":"CV","content":"\rA Cookbook of Self-Supervised Learning:\r#\rInitial Notes from: https://arxiv.org/abs/2304.12210 Intro:\r#\rNLP advanced due to SSL \u0026ndash;\u0026gt; No need of labelled data to train supervised model\nSSL -\u0026gt; Define a pretext task \u0026ndash;\u0026gt; Un-labelled data \u0026ndash;\u0026gt; intelligent representation\nNLP: Word2Vec is SSL \u0026ndash; In a sentence, mask a word and predict the surrounding words (It learns context)\nCV: 2 current popular ways:\nmask a patch and prediction of masked path\naugmented version of the same sample \u0026ndash;\u0026gt; train model such that embeddings from these 2 images are close as compared to any other image.\nWhy SSL is hard and need of cookbook\nComputational Cost\nNo detailed papers and its proper implementation with parameters\nunified vocab\nOrigin of SSL:\r#\rDiscussion about several pre-text tasks which were used few years ago in the field of SSL:\nInformation restoration:\nRemove something from image and restore it or convert to grayscale and train a ML model to predict the colors. This helps in learning object semantics and boundaries.\nNewer Method: Masked-AutoEncoding - Transformer based where patches are masked\nVideo Temporal Relationship:\nModel training using triplet loss for similarity of two representations of same object in 2 different frames.\nRemove audio track and predict it based on the video input\nPrediction of depth mapping between un-labelled image pairs.\nLearning spatial context:\nRandom rotation \u0026ndash;\u0026gt; predict the amount of rotation\nJigsaw: convert image to blocks and create pairs \u0026ndash;\u0026gt; predict the relative position of each pair.\n:\n"},{"id":9,"href":"/notes/general/unanswered-questions.html","title":"Un-Answered Questions","section":"General","content":"\rUn-Answered Questions:\r#\rDifference between Float16 vs Bfloat16 vs Tensor-Float16 ?\nVector Databases: HNSW vs IVF ?\nDifference between vector DB\u0026rsquo;s and FAISS library (by Meta) ?\nFrom my current knowledge both are same, but then why is everyone behind vector DB\u0026rsquo;s instead of using FAISS directly ? Null Hypothesis test \u0026raquo; p-values \u0026raquo; calculated using t-test or z-test\n"},{"id":10,"href":"/notes/general/vector-store-and-search.html","title":"Vector Search and Stores","section":"General","content":"Note: Just putting down few notes from AWS partner-cast session\nVector Search and Vector Stores\r#\rHow to measure similarity in embeddings?\r#\rCosine Similarity: Gives the angle between the 2 embeddings. Higher the angle, bigger is the difference between 2 embeddings.\nDot-Product: Same as cosine similarity but gives us the magnitude between 2 vectors instead of direction/angle.\nReal-life Use cases:\r#\rSemantic search\nRecommendation System\nAnomaly detection and pattern recognition\nGenAI: RAG (Retrieval Augmented Generation)\nRAG Implementation in AWS:\r#\rVector embedding is used to find top 3 most similar chunks\nIn the prompts, the context provided needs to be given in natural language i.e english and not in embeddings format\nRead about HNSW: Hierarchical Navigable Small Worlds (HNSW) | Pinecone\rand Nearest Neighbor Indexes: What Are ivfflat Indexes in pgvector and How Do They Work\rVector search is read-only\nRead about: Knn search vs ANN search\nRead about: Postgres integration with aurora and rds for vector search\n"},{"id":11,"href":"/notes/general/api-performance-improvement.html","title":"Web-API performance improvement","section":"General","content":"\rAPI Performance Improvement\r#\rBased on: Top 7 Ways to 10x Your API Performance - YouTube\rOptimization should not be the first step of development\n1. Caching:\r#\rIf same request is repeated multiple times \u0026ndash;\u0026gt; cache hence no need to recompute or hit the DB again.\nFor DB, its: MemCacheD or Redis\n2. Connection Pooling:\r#\rHaving continues connections with DB can slow down server as each connection requires a lot of handshake protocol. Hence, it s a good practice to already have a set of connections ready with each set of API. This is difficult in serverless applications like Lambda and can cause big problems:\nSolution (at-least on AWs): RDS Proxy:- It sits between DB and applications (including AWS Lambda) to efficiently manage the DB connections\n3. N+1 query problem:\r#\rIdeally, we should fetch data in a single request to Db instead of asking or querying it N times. Conclusion being, we should try to club requests to query our DB. 4. Pagination:\r#\rIf data to be fetched or requested from DB or server is huge, it will slow the response time \u0026ndash;\u0026gt; Hence we should paginate our response into multiple pages to reduce data transfer in single go.\n5. Json Serialization:\r#\rSerialization takes time \u0026hellip;hence consider ways to reduce that time\nExample: Can think of using gRPC or some json serialization library which is very fast.\n6. Compress API response payloads to reduce network latency.\r#\rGitHub - google/brotli: Brotli compression format\rVarious CDN also perform these tasks example: Cloudfare\n7. Async Logging:\r#\rLogging is important but writing logs during stream processing applications can cause bottleneck\nHence, in such scenarios it is better to log logs via async operations.\nBut, there is a small chance that the some logs can be missed in this case.\n"},{"id":12,"href":"/notes/general.html","title":"General","section":"Notes","content":""},{"id":13,"href":"/blogs.html","title":"Blogs","section":"","content":"\rList of Blogs:\r#\rBacktracking AWS Lookout for Vision Service\rDate: June23, 2022\nMedium Link: https://medium.com/@yogenyat/backtracking-aws-lookout-for-vision-service-136c47c85168\rFinding the nâ€™th Aggregate Value from Every Group in AWS Athena/Presto\rDate: June2, 2022\nMedium Link: https://medium.com/selectfrom/finding-the-nth-aggregate-value-from-every-group-in-aws-athena-presto-1da505310901\r"},{"id":14,"href":"/notes/cv.html","title":"CV","section":"Notes","content":""},{"id":15,"href":"/notes/nlp.html","title":"NLP","section":"Notes","content":""},{"id":16,"href":"/notes.html","title":"Notes","section":"","content":""},{"id":17,"href":"/project-experience.html","title":"Project Experience","section":"","content":"\rMy projects and industry experience:\r#\r{WORK IN PROGRESS:Â Sorry, I am yet to write things in this section. I have just created the template as of nowâ€¦.. }\nAdd this later in the main page: (markdown text)\n"},{"id":18,"href":"/resume/","title":"Resume","section":"","content":"\rPrevious\rNext \u0026nbsp; \u0026nbsp;\r/ [pdf]\rView the PDF file here.\r"}]