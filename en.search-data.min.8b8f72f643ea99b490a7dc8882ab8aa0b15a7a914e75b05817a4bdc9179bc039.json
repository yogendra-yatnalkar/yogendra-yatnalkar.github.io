[{"id":0,"href":"/notes/nlp/bert.html","title":"BERT","section":"Nlp","content":" BERT (Bidirectional Encoder Representation From Transformer)\r#\rSource:\nBERT: Pre-training of Deep Bidirectional Transformers for Language Understanding - YouTube\rOriginal Paper: https://arxiv.org/pdf/1810.04805v2.pdf\rSource:\nBERT Neural Network - EXPLAINED! - YouTube\rBefore BERT:\r#\rLSTM\u0026rsquo;s were used.\nProblems:\nSlow as each word is processed at a time (sequentially) Not truly bi-directional (left to right and right to left at a time in bidirectional LSTM) Bert Architecture: Multiple encoders stacked on each-other\nPretraining and Finetuning\nPretraining Task is used to learn the language and its context. It is done using two tasks:\nMask Language Model (MLM):\nSentence sentence {Fill_in_the_Blanks} remaining sentence\nHelps bert understand the bidirectional meaning of a sentence\nNext Sentence Prediction (NSP):\nPredict whether the a given sentence is the next sentence of the current sentence. Like a binary classification task.\nIt helps bert in understanding context across different sentences.\nUsually, the MLM task and NSP task are performed simultaneously.\nFinetuning:\nFinetune on task specific data.\nFast and compute efficient\nOnly replace last few layers of the original architecture\n"},{"id":1,"href":"/notes/general/general-general.html","title":"General Notes","section":"General","content":"\rLinux:\r#\rWget vs Curl\r#\rcurl and wget both support http and various types of FTP protocols. curl is library but wget is a CLI tool. curl is used for both way data transfer (src to detination and vice-versa) But, wget can be used only for single way data transfer, example: downloading something form a web-server. Null Hypothesis test \u0026raquo; p-values \u0026raquo; calculated using t-test or z-test \u0026raquo;\n"},{"id":2,"href":"/notes/general/kl-divergence.html","title":"Kullback-Leibler Divergence (KL Divergence)","section":"General","content":"\rKullback-Leibler Divergence (KL Divergence)\r#\rLast Edited 25/06/2023 Definition:\r#\rMeasures the distance between 2 prabability distributions Explanation + Proof:\r#\rBase Video: Intuitively Understanding the KL Divergence - YouTube\rSequence of flips: H -\u0026gt; H -\u0026gt; T \u0026hellip;..\nMultiply the probabilities from both the coins for the corresponding heads and tails. It is nothing but:\nfor True coin: P1 raise to something and P2 raise to something else\nFor coin2: Q1 raise to soemthing and Q2 raise to something else\nafter applying log to the RHS: (** \u0026ndash;\u0026gt; Explained at the end)\nAs the number of observations tends towards infinity:\nNh/n ~~ p1\nNt/N ~~ p2\nThis leads us to the final log expression:\nGeneral Formulae:\r#\r\u0026ldquo;This computes the distance between 2 distributions motivated by looking at how likely the 2nd distribution would be able to generate samples from the first distribution\u0026rdquo;\nCross-entropy Loss is very related to KL Divergence\nImportant Notes:\r#\rKL Divergence is un-symmetric i.e the divergence depends on the distribution placed on the denominator.\nIn other words: Divergence of distribution1 wrt distribution2 is not same as divergence of distribution2 wrt distribution1.\n** Why take log of probability ?\r#\rFrom the probabilities of ratio, why did we suddenly take log of ratio ??\nThe log of probabilities is closely related entropy. In information theory\r, the entropy of a random variable\ris the average level of \u0026ldquo;information\u0026rdquo;, \u0026ldquo;surprise\u0026rdquo;, or \u0026ldquo;uncertainty\u0026rdquo; inherent to the variable\u0026rsquo;s possible outcomes.\nKL Divergence is also known as relative entropy between 2 distributions.\r#\rFor good reference to entropy, watch statquest video:\nEntropy (for data science) Clearly Explained!!! - YouTube\r"},{"id":3,"href":"/notes/cv/sam-segment-anything.html","title":"SAM-Segment-Anything","section":"Cv","content":"\rSegment Anything (SAM)\r#\rLast Edited 16/07/2023 Source: - Original Paper (notes till page no 7) - Youtube: https://www.youtube.com/watch?v=eYhvJR4zFUM Introduction:\r#\rFoundation model for segmentation.\nImportant thing to note here, is that SAM is not just for semantic segmentation but can also be used for instance or panoptic or salient segmentation as well. We just need to engineer it accordingly.\nTrained ON: 11 million images and 1 billion corresponding masks\nEarlier foundation model: Clip and Align \u0026raquo; Now getting used in other downstream tasks like image generation (DALL-E).\nTo build foundation mode, 3 things are necessary:\nTask\nModel\nDataset and Data-Engine\nTask\r#\rTask: Prompt-able segmentation task \u0026raquo; prompt can be text or mask or BB or points \u0026raquo; even if prompt is not accurate or it is confusing, the output should be good.\nZero-shot transfer: Example- if you have a OD model to detect cats, SAM can be used to segment each cat (instance segmentation) in your image. If you want semantic segmentation, convert that cat instances to single class.\nSAM vs Other multi-segmentation models:\nOther models are not general. They do a set of predefined tasks they are trained on, they can be many but fixed.\nIn case of SAM, it can be engineered to perform any task with itself alone or with other systems (example: OD model or older segmentation model). The prompt makes it key here and forms a general foundation model.\nModel:\r#\rModel: Heavy and powerful image encoder, light prompt encoder, light++ prompt and image decoder.\nImport thing to note: for faster inference, the encoder can be hosted online on server, but prompt encoder and decoder can be hosted on edge (eg. browser). Hence reducing the network latency. ++ We need to encode only once, then we can prompt it as many times as needed.\nSAM predicts multiple masks for single image (to battle confusion)\nImage Encoder: Image encoder is pretrained ViT from MAE (Masked Auto-Encoders are Scalable Vision Learners). In MAE, random patches from ViT are masked and an autoencoder is trained to predict the masked patch.\nSAM uses this MAE encoder as its base encoder\nPrompt Encoder:\nText: Encoded using CLIP\nBounding box coordinates or point coordinates: Positional Encoder with summed learned embedding\nMask: Embedding from CNN\nMask Decoder:\nInspired from original Transformer decoder. (modified)\nOutput of decoder goes to dynamic prediction head\nUses self-attention and cross-attention between prompt and image-embedding in bi-directional way (i.e prompt-to-image embedding and vice-versa)\nLater, up-sample and pass it to a linear classifier\nAmbiguity and Backprop: For each input, 3 masks are predicted and during backprop for loss computation, the mask with least amount of loss is counted. Loss is computed using IoU.\nEfficiency: Post encoder embedding, the prompt encoder and decoder can work on CPU (web-browser) with 50 ms latency.\nLoss metrics used: Focal loss and Dice Loss\nFocal Loss: Focal Loss is am improved version of Cross-Entropy Loss that tries to handle the class imbalance problem by down-weighting easy negative class and focusing training on hard positive classes. In paper, Focal Loss is mathematically defined as: Reference: Understanding Cross-Entropy Loss and Focal Loss | Multiplying Matrices for a living (theguywithblacktie.github.io)\r(Do read it, very good explanation) Note: Focal loss was initially used for object detection (invented at FAIR)\nDice Loss: Dice loss is 1 - Dice Coefficient. You can directly imagine Dice Coefficient as IoU.\nDataset\r#\rDataset and Data-Engine: 11 mil images, 1 billion masks. Tag with the help of model, retrain and retag \u0026ndash;\u0026gt; Cycle continues\u0026hellip;\nResponsible AI: Images are taken from all over the globe across all human species. "},{"id":4,"href":"/notes/cv/segformer.html","title":"SegFormer: Segmentation using Transformer","section":"Cv","content":"\rSegFormer: Segmentation using Transformer\r#\rLast Edited 16/07/2023 Source: SegFormer: Simple and Efficient Design for Semantic Segmentation with Transformers - YouTube\rInput patch size: 4x4\nIn ViT, it was 16x16, but with smaller path size, the authors said, smaller batch size is better (and required) for dense prediction.\nNote: With reducing the patch size, the computation increases.\nAfter each transformer block (encoder in this case), there is a feed-forward block which is mainly used to lower the dimension like older UNet \u0026ndash;\u0026gt; i.e in HxWxC \u0026hellip;. as we go ahead in the encoder block, the height and width will decrease but the number of channels will keep on increasing.\nIn normal ViT as well, there are multiple transformer blocks, output dimension of each block of encoder is same its input.\nThese MLP blocks used in the encoder (Not transformer encoder), not just downsample the input (and increase channels) but also dynamically adjusts the patch embedding vector passed on to the next transformer block.\nEfficient self-attention reduces the sequence to lower computation cost (NOTE: Later need to read about efficient self attention)\nThe segformer decoder consists of Dense NN (MLP) which has upsamping blocks in between.\nImportant: One big achievement of segformer is, it not just has high mIoU, its Params size is also very small\u0026hellip;.. hence inference speed is also high.\n"},{"id":5,"href":"/notes/cv/self-supervised-learning.html","title":"Self Supervised Learning","section":"Cv","content":"\rA Cookbook of Self-Supervised Learning:\r#\rInitial Notes from: https://arxiv.org/abs/2304.12210 Intro:\r#\rNLP advanced due to SSL \u0026ndash;\u0026gt; No need of labelled data to train supervised model\nSSL -\u0026gt; Define a pretext task \u0026ndash;\u0026gt; Un-labelled data \u0026ndash;\u0026gt; intelligent representation\nNLP: Word2Vec is SSL \u0026ndash; In a sentence, mask a word and predict the surrounding words (It learns context)\nCV: 2 current popular ways:\nmask a patch and prediction of masked path\naugmented version of the same sample \u0026ndash;\u0026gt; train model such that embeddings from these 2 images are close as compared to any other image.\nWhy SSL is hard and need of cookbook\nComputational Cost\nNo detailed papers and its proper implementation with parameters\nunified vocab\nOrigin of SSL:\r#\rDiscussion about several pre-text tasks which were used few years ago in the field of SSL:\nInformation restoration:\nRemove something from image and restore it or convert to grayscale and train a ML model to predict the colors. This helps in learning object semantics and boundaries.\nNewer Method: Masked-AutoEncoding - Transformer based where patches are masked\nVideo Temporal Relationship:\nModel training using triplet loss for similarity of two representations of same object in 2 different frames.\nRemove audio track and predict it based on the video input\nPrediction of depth mapping between un-labelled image pairs.\nLearning spatial context:\nRandom rotation \u0026ndash;\u0026gt; predict the amount of rotation\nJigsaw: convert image to blocks and create pairs \u0026ndash;\u0026gt; predict the relative position of each pair.\n:\n"},{"id":6,"href":"/notes/general/api-performance-improvement.html","title":"Web-API performance improvement","section":"General","content":"\rAPI Performance Improvement\r#\rBased on: Top 7 Ways to 10x Your API Performance - YouTube\rOptimization should not be the first step of development\n1. Caching:\r#\rIf same request is repeated multiple times \u0026ndash;\u0026gt; cache hence no need to recompute or hit the DB again.\nFor DB, its: MemCacheD or Redis\n2. Connection Pooling:\r#\rHaving continues connections with DB can slow down server as each connection requires a lot of handshake protocol. Hence, it s a good practice to already have a set of connections ready with each set of API. This is difficult in serverless applications like Lambda and can cause big problems:\nSolution (at-least on AWs): RDS Proxy:- It sits between DB and applications (including AWS Lambda) to efficiently manage the DB connections\n3. N+1 query problem:\r#\rIdeally, we should fetch data in a single request to Db instead of asking or querying it N times. Conclusion being, we should try to club requests to query our DB. 4. Pagination:\r#\rIf data to be fetched or requested from DB or server is huge, it will slow the response time \u0026ndash;\u0026gt; Hence we should paginate our response into multiple pages to reduce data transfer in single go.\n5. Json Serialization:\r#\rSerialization takes time \u0026hellip;hence consider ways to reduce that time\nExample: Can think of using gRPC or some json serialization library which is very fast.\n6. Compress API response payloads to reduce network latency.\r#\rGitHub - google/brotli: Brotli compression format\rVarious CDN also perform these tasks example: Cloudfare\n7. Async Logging:\r#\rLogging is important but writing logs during stream processing applications can cause bottleneck\nHence, in such scenarios it is better to log logs via async operations.\nBut, there is a small chance that the some logs can be missed in this case.\n"},{"id":7,"href":"/notes.html","title":"Notes","section":"Yogendra Yatnalkar","content":""},{"id":8,"href":"/notes/cv.html","title":"Cv","section":"Notes","content":""},{"id":9,"href":"/notes/cv/bringyourownlatent-byol.html","title":"Bring Your Own Latent Byol","section":"Cv","content":"\rBootstrap Your Own Latent (BYOL):\r#\rTags: Self-Supervised Learning, SSL,\nSource: BYOL: Bootstrap Your Own Latent: A New Approach to Self-Supervised Learning (Paper Explained) - YouTube\r"},{"id":10,"href":"/notes/cv/object-detection-general.html","title":"Object Detection General","section":"Cv","content":"\rObject Detection Notes:\r#\r"},{"id":11,"href":"/notes/general.html","title":"General","section":"Notes","content":""},{"id":12,"href":"/notes/nlp.html","title":"Nlp","section":"Notes","content":""},{"id":13,"href":"/notes/nlp/nlp_general.html","title":"Nlp General","section":"Nlp","content":""},{"id":14,"href":"/blogs.html","title":"Blogs","section":"Yogendra Yatnalkar","content":""}]